from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form, Response
from sqlalchemy.orm import Session
from typing import List, Optional
import uuid
from datetime import datetime, date, timedelta
import pytz
import openpyxl
from io import BytesIO
from sqlalchemy import func

from app.database import get_db
from app.models import TreasuryNotification, Request, User, Import
from app.schemas import RequestResponse, ImportType, Category
from app.auth import get_current_user, require_treasury
from app.utils.excel_processor import process_excel_file

router = APIRouter()

# Создаем схему для ответа с уведомлениями
from pydantic import BaseModel
from typing import Optional as Opt
from uuid import UUID
import pytz

class TreasuryNotificationResponse(BaseModel):
    id: UUID
    approval_process_id: Opt[UUID]
    category: str
    deputy_name: str
    comment: str
    request_count: int
    total_amount: float
    is_read: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

@router.get("/notifications", response_model=List[TreasuryNotificationResponse])
async def get_notifications(
    unread_only: bool = False,
    current_user: User = Depends(require_treasury),
    db: Session = Depends(get_db)
):
    """
    Получение уведомлений от заместителя ГД
    """
    query = db.query(TreasuryNotification)
    
    if unread_only:
        query = query.filter(TreasuryNotification.is_read == False)
    
    notifications = query.order_by(TreasuryNotification.created_at.desc()).all()
    
    return notifications

@router.post("/notifications/{notification_id}/mark-read")
async def mark_notification_read(
    notification_id: uuid.UUID,
    current_user: User = Depends(require_treasury),
    db: Session = Depends(get_db)
):
    """
    Отметка уведомления как прочитанного
    """
    notification = db.query(TreasuryNotification).filter(
        TreasuryNotification.id == notification_id
    ).first()
    
    if not notification:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Уведомление не найдено"
        )
    
    notification.is_read = True
    db.commit()
    
    return {"message": "Уведомление отмечено как прочитанное"}

@router.get("/for-payment", response_model=List[RequestResponse])
async def get_requests_for_payment(
    category: Category = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    current_user: User = Depends(require_treasury),
    db: Session = Depends(get_db)
):
    """
    Получение заявок к оплате
    """
    query = db.query(Request).filter(Request.status == "for_payment")
    
    if category:
        query = query.filter(Request.category == category)
    
    if start_date:
        query = query.filter(Request.created_at >= start_date)
    
    if end_date:
        query = query.filter(Request.created_at <= end_date)
    
    requests = query.order_by(
        Request.priority.desc() if Request.priority else None,
        Request.created_at
    ).all()
    
    return requests


@router.get("/approved-for-payment", response_model=List[RequestResponse])
async def get_approved_requests_for_payment(
    category: Category = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    current_user: User = Depends(require_treasury),
    db: Session = Depends(get_db)
):
    """
    Получение заявок, согласованных в оплату
    """
    query = db.query(Request).filter(Request.status == "approved_for_payment")

    if category:
        query = query.filter(Request.category == category)

    if start_date:
        query = query.filter(Request.created_at >= start_date)

    if end_date:
        query = query.filter(Request.created_at <= end_date)

    requests = query.order_by(
        Request.priority.desc() if Request.priority else None,
        Request.created_at
    ).all()

@router.post("/export")

    return requests
async def export_requests(
    request_ids: List[uuid.UUID] = None,
    export_all: bool = False,
    current_user: User = Depends(require_treasury),
    db: Session = Depends(get_db)
):
    """
    Экспорт заявок в Excel
    """
    import logging
    logger = logging.getLogger(__name__)
    
    logger.info(f"Export request: export_all={export_all}, request_ids={request_ids}")
    
    query = db.query(Request).filter(Request.status == "for_payment")
    
    logger.info(f"Initial query count: {query.count()}")
    
    if not export_all and request_ids:
        logger.info(f"Filtering by request_ids: {request_ids}")
        query = query.filter(Request.id.in_(request_ids))

    requests = query.all()
    logger.info(f"Found {len(requests)} requests for export")

    if not requests:
        logger.warning("No requests found for export")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Нет заявок для экспорта"
        )

    # Создание Excel файла
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = "Заявки к оплате"

    # Заголовки
    headers = [
        "Статья ДДС", "Сумма", "Получатель", "Номер заявки",
        "Дата заявки", "Статус", "Организация", "Подразделение",
        "Приоритет", "Назначение", "Дата оплаты", "Заявитель"
    ]

    for col_num, header in enumerate(headers, 1):
        worksheet.cell(row=1, column=col_num, value=header)

    # Данные
    for row_num, request in enumerate(requests, 2):
        worksheet.cell(row=row_num, column=1, value=request.article)
        worksheet.cell(row=row_num, column=2, value=request.amount)
        worksheet.cell(row=row_num, column=3, value=request.recipient)
        worksheet.cell(row=row_num, column=4, value=request.request_number)
        worksheet.cell(row=row_num, column=5, value=request.request_date.strftime("%d.%m.%Y %H:%M:%S"))
        worksheet.cell(row=row_num, column=6, value=request.status)
        worksheet.cell(row=row_num, column=7, value=request.organization)
        worksheet.cell(row=row_num, column=8, value=request.department)
        worksheet.cell(row=row_num, column=9, value=request.priority)
        worksheet.cell(row=row_num, column=10, value=request.purpose)
        worksheet.cell(row=row_num, column=11, value=request.payment_date.strftime("%d.%m.%Y") if request.payment_date else "")
        worksheet.cell(row=row_num, column=12, value=request.applicant)

    # Сохранение в буфер
    from io import BytesIO
    excel_buffer = BytesIO()
    workbook.save(excel_buffer)
    excel_buffer.seek(0)

    # Создание имени файла
    filename = f"Заявки_к_оплате_{datetime.now().strftime('%d-%m-%Y_%H-%M')}.xlsx"
    
    logger.info(f"Export completed: {len(requests)} requests, filename: {filename}")

    # Возвращаем файл как ответ
    return Response(
        content=excel_buffer.getvalue(),
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={
            "Content-Disposition": f"attachment; filename={filename}"
        }
    )
async def special_import(
    import_type: ImportType = Form(...),
    file: UploadFile = File(...),
    current_user: User = Depends(require_treasury),
    db: Session = Depends(get_db)
):
    """
    Импорт особых заявок (непереносимые оплаты, графики, согласовано в оплату)
    """
    # Валидация файла
    if file.size > 5 * 1024 * 1024:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Файл превышает лимит 5 МБ"
        )
    
    # Создание записи об импорте
    db_import = Import(
        user_id=current_user.id,
        file_name=file.filename,
        file_size=file.size,
        payment_date=date.today(),
        import_type=import_type.value,
        status="processing"
    )
    
    db.add(db_import)
    db.commit()
    db.refresh(db_import)
    
    imported_count = 0
    
    try:
        # Чтение файла
        content = await file.read()
        
        # Обработка Excel файла
        requests_data = process_excel_file(content)
        
        for request_data in requests_data:
            # Создание особой заявки
            db_request = Request(
                article=request_data.get("Статья ДДС", ""),
                amount=float(request_data.get("Сумма", 0)),
                recipient=request_data.get("Получатель", ""),
                request_number=request_data.get("Номер заявки", ""),
                request_date=pytz.timezone('Europe/Moscow').localize(datetime.strptime(
                    request_data.get("Дата заявки", datetime.now().strftime("%d.%m.%Y %H:%M:%S")),
                    "%d.%m.%Y %H:%M:%S"
                )),
                organization=request_data.get("Организация", ""),
                department=request_data.get("Подразделение", ""),
                purpose=request_data.get("Назначение", ""),
                applicant=request_data.get("Заявитель", ""),
                category=import_type.value,
                import_type=import_type.value,
                created_by=current_user.id,
                status="approved_for_payment" if import_type == ImportType.APPROVED_FOR_PAYMENT else "for_payment"
            )
            
            db.add(db_request)
            imported_count += 1
        
        # Обновление статуса импорта
        db_import.status = "completed"
        db_import.imported_count = imported_count
        db.commit()
        
    except Exception as e:
        # В случае ошибки
        db_import.status = "failed"
        db_import.error_message = str(e)
        db.commit()
        
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка при импорте: {str(e)}"
        )
    
    return {
        "message": f"Импорт завершен успешно",
        "imported_count": imported_count,
        "import_type": import_type.value
    }

@router.post("/update-payment-date")
async def update_payment_date(
    request_ids: List[uuid.UUID],
    payment_date: date,
    current_user: User = Depends(require_treasury),
    db: Session = Depends(get_db)
):
    """
    Обновление даты оплаты для выбранных заявок
    """
    requests = db.query(Request).filter(
        Request.id.in_(request_ids),
        Request.status.in_(["for_payment", "approved_for_payment"])
    ).all()
    
    if not requests:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заявки не найдены или не могут быть оплачены"
        )
    
    # Обновление даты оплаты
    for request in requests:
        request.payment_date = payment_date
        request.updated_at = datetime.utcnow()
    
    db.commit()
    
    return {
        "message": f"Дата оплаты обновлена для {len(requests)} заявок",
        "count": len(requests),
        "payment_date": payment_date.strftime("%d.%m.%Y")
    }

@router.get("/statistics")
async def get_treasury_statistics(
    period: str = "month",  # day, week, month, year
    current_user: User = Depends(require_treasury),
    db: Session = Depends(get_db)
):
    """
    Получение статистики для казначейства
    """
    # Расчет дат в зависимости от периода
    end_date = datetime.now()
    
    if period == "day":
        start_date = end_date.replace(hour=0, minute=0, second=0, microsecond=0)
    elif period == "week":
        start_date = end_date - timedelta(days=7)
    elif period == "month":
        start_date = end_date - timedelta(days=30)
    elif period == "year":
        start_date = end_date - timedelta(days=365)
    else:
        start_date = end_date - timedelta(days=30)
    
    # Статистика по статусам
    status_stats = {}
    for status in ["for_payment", "approved_for_payment", "rejected"]:
        query = db.query(Request).filter(
            Request.status == status,
            Request.updated_at >= start_date,
            Request.updated_at <= end_date
        )
        
        count = query.count()
        
        if count > 0:
            total_amount = db.query(func.sum(Request.amount)).filter(
                Request.status == status,
                Request.updated_at >= start_date,
                Request.updated_at <= end_date
            ).scalar() or 0
            
            status_stats[status] = {
                "count": count,
                "total_amount": total_amount
            }
    
    # Статистика по категориям
    category_stats = {}
    categories = db.query(Request.category).distinct().all()
    
    for category_tuple in categories:
        category = category_tuple[0]
        query = db.query(Request).filter(
            Request.category == category,
            Request.status.in_(["for_payment", "approved_for_payment"]),
            Request.updated_at >= start_date,
            Request.updated_at <= end_date
        )
        
        count = query.count()
        
        if count > 0:
            total_amount = db.query(func.sum(Request.amount)).filter(
                Request.category == category,
                Request.status.in_(["for_payment", "approved_for_payment"]),
                Request.updated_at >= start_date,
                Request.updated_at <= end_date
            ).scalar() or 0
            
            category_stats[category] = {
                "count": count,
                "total_amount": total_amount
            }
    
    return {
        "period": period,
        "start_date": start_date,
        "end_date": end_date,
        "status_statistics": status_stats,
        "category_statistics": category_stats,
        "total_requests": sum([stats["count"] for stats in status_stats.values()]),
        "total_amount": sum([stats["total_amount"] for stats in status_stats.values()])
    }
